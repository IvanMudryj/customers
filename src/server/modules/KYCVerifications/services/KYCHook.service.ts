import { AxiosResponse } from "axios";
import config from "../../../../config";
import logger from "../../../../utils/logger";
import CUIT from "../../../../utils/cuit";
import { MetamapHttpWrapper } from "./MetamapHttpService";
import { KYCFlowsRepository, KYCVerificationFlowsRepository, KYCVerificationsRepository } from "../database/repository";
import { EKYCVerificationFlowStatus, EKYCVerificationStatus, IKYCVerificationFlow, IKYCVerificationFlowStep } from "../domain/interface";
import { Metamap_HookResponse, SEP09Fields, V4UUID } from "../interfaces/FlowMetadata.interface";
import { CallbackHttpWrapper } from "./CallbackHttpService";
import { KYCVerificationEntity, KYCVerificationPK } from "../domain/interface/KYCVerifications.interface";

const processKYCHook = async (bodyPayload:any) : Promise<void> => {
  try {
    logger.info("processKYCHook");
  
    const hookData:Metamap_HookResponse = bodyPayload;
    const ResourceID = hookData.resource.split('/')[hookData.resource.split('/').length - 1];

    const oCallbackConfig:any = {};
    const oFlow = await KYCFlowsRepository.findByPk(hookData.flowId);
    if(!oFlow) throw new Error("Invalid FlowID");
    else {
      oCallbackConfig.events = oFlow.EventsCallbackUrl;
      oCallbackConfig.identity = oFlow.IdentityInfoCallbackUrl;
    }

    const IdKYCVerification:V4UUID | undefined = hookData.metadata?.IdKYCVerification;
    if(IdKYCVerification)
      await KYCVerificationsRepository.createIfNotExists({
        IdKYCVerification: IdKYCVerification,
        ResponseStatus: 'autogenerated',
        IdKYCVerificationStatus: EKYCVerificationStatus.READY,
        Request: {flowId: hookData.flowId,"metadata": hookData.metadata },
        Response: bodyPayload,
        CallbackConfig: oCallbackConfig
      });

    const StepData = bodyPayload;
    let StepError, StepCode=hookData.eventName, IdKYCVerificationFlowStatus:EKYCVerificationFlowStatus;
    if(hookData.step) {
      StepCode = hookData.step.id;
      StepError = hookData.step.error;
    } 
    let bPostCallbackEvent:string | null = null;
    switch (hookData.eventName) {   //verification_started //step_completed  //verification_inputs_completed //verification_completed //verification_updated  //verification_expired  //verification_signed
      case 'verification_started':
          IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.STARTED;
          //CALLBACK TO NOTIFY ABOUT STATUS CHANGE
          bPostCallbackEvent = hookData.eventName;
        break;
      case 'verification_inputs_completed':  
          KYCVerificationsRepository.updateStatus(IdKYCVerification!, EKYCVerificationStatus.READY);
          IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.INPUTS_COMPLETED;
          //CALLBACK TO NOTIFY ABOUT STATUS CHANGE
          bPostCallbackEvent = hookData.eventName;
        break;
      case 'step_completed':
        //KYCVerificationsRepository.updateStatus(IdKYCVerification!, EKYCVerificationStatus.VALIDATING); //No se si cambiar aca... quizas lo sacamos
        IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.PROCESSING_STEPS;
        break;
      case 'verification_expired':  
        KYCVerificationsRepository.updateStatus(IdKYCVerification!, EKYCVerificationStatus.ABANDONED);
        IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.ABANDONED;
        break;
      case 'verification_completed':    
        KYCVerificationsRepository.updateStatus(IdKYCVerification!, EKYCVerificationStatus.PROCESSING);    
        IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.FINISHED;
        break;
      case 'verification_updated':
        KYCVerificationsRepository.updateStatus(IdKYCVerification!, EKYCVerificationStatus.PROCESSING);  
        IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.UPDATED;
        break;
      case 'verification_signed':
        logger.info("Verification Signature step ignored");
        return;
      default: 
        logger.info("processKYCHook ???", hookData.eventName);
        IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.STARTED;
        break;
    }
    
    //FLOW
    let oKYCVerificationFlow:IKYCVerificationFlow = { 
      IdKYCVerification: IdKYCVerification, 
      ResourceID: ResourceID, 
      MetaData: JSON.stringify(hookData.metadata), 
      FlowID: hookData.flowId,
      IdKYCVerificationFlowStatus: IdKYCVerificationFlowStatus
    }
    oKYCVerificationFlow = await KYCVerificationFlowsRepository.createOrUpdateByResourceID(oKYCVerificationFlow);

    if(bPostCallbackEvent) postCallbackEvent(oKYCVerificationFlow, bPostCallbackEvent);

    //FLOW_STEP
    let oKYCVerificationFlowStep:IKYCVerificationFlowStep = { 
      IdKYCVerificationFlow: oKYCVerificationFlow.IdKYCVerificationFlow!,
      EventCode: hookData.eventName, 
      StepIdentifier: StepCode,
      EventBody: StepData,
      EventError: StepError
    }
    oKYCVerificationFlowStep = await KYCVerificationFlowsRepository.createStep(oKYCVerificationFlow, oKYCVerificationFlowStep);

    if(hookData.eventName === 'verification_completed' || hookData.eventName === 'verification_updated') // completed o updated?
      processkycSteps(oKYCVerificationFlow, hookData.identityStatus!);

    return;
  } catch (e:any) {
    logger.error('MATI_HOOK_ERROR', { message: e.message, detail: JSON.stringify({ bodyPayload })});
    return;
  }
}

const processkycSteps = (oKYCVerificationFlow: IKYCVerificationFlow, IdentityStatus: string) => {
  try {
    
    let IdKYCVerificationStatus = EKYCVerificationStatus.PROCESSING;
    switch(IdentityStatus)
    {
      case "reviewNeeded":
        IdKYCVerificationStatus = EKYCVerificationStatus.MANUAL_VALIDATION;
        break;
      case "reviewRunning":
        IdKYCVerificationStatus = EKYCVerificationStatus.PROCESSING;
        break;
      case "verified":
        IdKYCVerificationStatus = EKYCVerificationStatus.VALIDATION_SUCCEED;
        break;
      case "rejected": 
        IdKYCVerificationStatus = EKYCVerificationStatus.VALIDATION_REJECTED;
        break;
    }

    return KYCVerificationsRepository.update(oKYCVerificationFlow, { IdKYCVerificationStatus: IdKYCVerificationStatus, ResponseStatus: IdentityStatus })
    .then(async () =>{
      //CALLBACK TO NOTIFY ABOUT STATUS CHANGE
      postCallbackEvent(oKYCVerificationFlow, IdentityStatus);
      return MapVerificationFields(oKYCVerificationFlow)
      .then(async (identityMap:any) =>{
        //CALLBACK TO PROVIDE IDENTITY INFO
        postCallbackIdentity(oKYCVerificationFlow, identityMap, IdentityStatus);
        return; 
      })
    });

  } catch (e:any) {
    logger.error('MATI_PROCESS_ERROR', { message: e.message, detail: JSON.stringify({ IdKYCVerificationFlow : oKYCVerificationFlow.IdKYCVerification, IdentityStatus })});
    return;
  }
}

const MapVerificationFields = async (oKYCVerificationFlow: IKYCVerificationFlow) : Promise<any> => {
  try {

    const oVerificationResponse:AxiosResponse<any> = await MetamapHttpWrapper.get(`${config.metamap.verification_endpoint}${oKYCVerificationFlow.ResourceID}`);
    await KYCVerificationFlowsRepository.update(oKYCVerificationFlow.IdKYCVerificationFlow!, { ResourceBody: oVerificationResponse.data });

    let oDocument = oVerificationResponse.data.documents[0];
    let oSEP12Body:SEP09Fields = {};
    if(oDocument.country) {

      oSEP12Body.address_country_code = oDocument.country;
      oSEP12Body.id_country_code = oDocument.country;

      if(oDocument.fields?.nationality)
        oSEP12Body.birth_country_code = oDocument.fields.nationality.value;

      if(oDocument.fields.documentNumber) {
        switch(oDocument.country)
        {
          case "AR": //Especial para Argentina Renaper
              var oStepRenaper = oDocument.steps.find((step:any) => step.id == "argentinian-renaper-validation" && step.error == null);
              if(oStepRenaper && oStepRenaper.data && oStepRenaper.data.cuit) {
                oSEP12Body.id_number = oStepRenaper.data.cuit;
                oSEP12Body.id_type = 'CUIT';
              }
              else {
                try {
                  oSEP12Body.id_number = CUIT.calculateCuilCuit(oDocument.fields.documentNumber.value.replace(/([^a-z0-9]+)/gi, ''),  oDocument.fields.sex.value);
                  oSEP12Body.id_type = 'CUIT';
                }
                catch(e)
                {
                  oSEP12Body.id_number =  oDocument.fields.documentNumber.value.replace(/([^a-z0-9]+)/gi, '');
                  if(oDocument.type == 'national-id' && oDocument.fields.documentType == 'ID')
                    oSEP12Body.id_type = 'NATIONAL-ID';
                  else if(oDocument.fields.documentType == 'P' || oDocument.type == 'passport')
                    oSEP12Body.id_type = 'PASSPORT';
                }
              }
            break;
          default:
            oSEP12Body.id_number = oDocument.fields.documentNumber.value.replace(/([^a-z0-9]+)/gi, '');
            oSEP12Body.id_type = oDocument.type.toUpperCase();
        }
      }

      if(oDocument.fields.firstName)
        oSEP12Body.first_name = oDocument.fields.firstName.value;

      if(oDocument.fields.sex)
        oSEP12Body.sex = oDocument.fields.sex.value;

      if(oDocument.fields.emissionDate)
        oSEP12Body.id_issue_date = oDocument.fields.emissionDate.value;
      
      if(oDocument.fields.expirationDate)
        oSEP12Body.id_expiration_date = oDocument.fields.expirationDate.value;

      if(oDocument.fields.lastName || oDocument.fields.surname)
        oSEP12Body.last_name = (oDocument.fields.lastName) ? oDocument.fields.lastName.value : oDocument.fields.surname.value;
      else if(oDocument.fields.fullName)
        oSEP12Body.last_name = oDocument.fields.fullName.value.replace(oSEP12Body.first_name, '');

      if(oDocument.fields.state)
        oSEP12Body.state_or_province =  oDocument.fields.state.value;

      if(oDocument.fields.city)
        oSEP12Body.city =  oDocument.fields.city.value;

      if(oDocument.fields.zipcode)
        oSEP12Body.postal_code =  oDocument.fields.zipcode.value;

      if(oDocument.fields.dateOfBirth)
        oSEP12Body.birth_date =  oDocument.fields.dateOfBirth.value;

      if(oDocument.fields.address)
        oSEP12Body.address =  oDocument.fields.address.value;

      if(oDocument.photos[0])
        oSEP12Body.photo_id_front =  oDocument.photos[0];

      if(oDocument.photos[1])
        oSEP12Body.photo_id_back =  oDocument.photos[1];

      const oSelfieStep = oVerificationResponse.data.steps.find((i:any) => i.id == 'selfie');
      if(oSelfieStep?.data)
        oSEP12Body.photo_selfie =  oSelfieStep.data.selfiePhotoUrl;
    }

    let IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.FINISHED;
    switch(oVerificationResponse.data.identity?.status) {
      case "reviewNeeded":
        IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.MANUAL_VALIDATION;
        break;
      case "verified":
        IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.VALIDATION_SUCCEED;
        break;
      case "rejected": 
      IdKYCVerificationFlowStatus = EKYCVerificationFlowStatus.VALIDATION_REJECTED;
        break;
    }  

    await KYCVerificationFlowsRepository.update(oKYCVerificationFlow.IdKYCVerificationFlow!, { IdentityData: oSEP12Body, IdKYCVerificationFlowStatus: IdKYCVerificationFlowStatus });
    const oVerificationData = {
      IdKYCVerificationFlow: oKYCVerificationFlow.IdKYCVerificationFlow,
      IdentityStatus: oVerificationResponse.data.identity?.status
    }
    await KYCVerificationsRepository.update(oKYCVerificationFlow.IdKYCVerification!, { VerificationData: oVerificationData });
    return oSEP12Body;

  } catch (e:any) {
    logger.error('MATI_MAPPING_ERROR', { message: e.message, detail: JSON.stringify({ IdKYCVerificationFlow : oKYCVerificationFlow.IdKYCVerification })});
    return;
  }
}

const postCallbackEvent = async (oKYCVerificationFlow:IKYCVerificationFlow, eventName:string) => {
  const oResponseData = {
    eventName
  };
  return postCallbackData("events", oKYCVerificationFlow.IdKYCVerification!, oResponseData);
}

const postCallbackIdentity = (oKYCVerificationFlow:IKYCVerificationFlow, IdentityData:any, IdentityStatus:string) => {
  const oResponseData = {
    status: IdentityStatus,
    identity: IdentityData,
  };
  return postCallbackData("identity", oKYCVerificationFlow.IdKYCVerification!, oResponseData);
}

const postCallbackData = async (Type:string, IdKYCVerification:KYCVerificationPK, CallbackData:any) => {
  const oKYCVerification:KYCVerificationEntity = await KYCVerificationsRepository.findByPk(IdKYCVerification);
  const sURL:string | null = oKYCVerification.CallbackConfig![Type];
  if(sURL) CallbackHttpWrapper.post(oKYCVerification.CallbackConfig![Type], CallbackData);
  return;
}

export {
  processKYCHook
};